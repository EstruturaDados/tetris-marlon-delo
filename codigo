/*
  Tetris Stack - Gerenciador Unificado de Pecas
  - Fila circular de futuras pecas (QSIZE = 5)
  - Pilha de reserva (STACK_CAP = 3)
  - Operacoes:
      1 - Jogar peca (dequeue)
      2 - Reservar peca (dequeue -> push)
      3 - Usar peca reservada (pop)
      4 - Trocar frente da fila com topo da pilha (swap)
      5 - Trocar os 3 primeiros da fila com as 3 pecas da pilha (swap em bloco)
      6 - Mostrar estado
      0 - Sair
  - A cada remocao efetiva (jogar, reservar, usar reservada) o sistema tenta gerar e enfileirar
    uma nova peca para manter a fila sempre cheia quando possivel.
  - Pecas: tipo ('I','O','T','L') e id unico sequencial.
  - Codigo comentado para legibilidade.
*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#define QSIZE 5
#define STACK_CAP 3

typedef struct {
    char tipo; /* 'I','O','T','L' */
    int id;    /* identificador unico */
} Peca;

/* Fila circular */
typedef struct {
    Peca dados[QSIZE];
    int frente; /* indice do elemento da frente (proximo a ser jogado) */
    int tras;   /* indice da posicao de insercao seguinte */
    int qtd;    /* quantidade atual de elementos */
} FilaPecas;

/* Pilha simples */
typedef struct {
    Peca dados[STACK_CAP];
    int topo;   /* -1 quando vazia; topo aponta para ultimo inserido */
    int qtd;
} PilhaPecas;

/* ID sequencial global */
static int proximoId = 0;

/* ---------- Geracao de pecas ---------- */

char gerarTipoAleatorio() {
    int r = rand() % 4;
    switch (r) {
        case 0: return 'I';
        case 1: return 'O';
        case 2: return 'T';
        default: return 'L';
    }
}

Peca gerarPeca() {
    Peca p;
    p.tipo = gerarTipoAleatorio();
    p.id = proximoId++;
    return p;
}

/* ---------- Fila (circular) ---------- */

void inicializarFila(FilaPecas *f) {
    f->frente = 0;
    f->tras = 0;
    f->qtd = 0;
}

int filaCheia(const FilaPecas *f) { return f->qtd == QSIZE; }
int filaVazia(const FilaPecas *f) { return f->qtd == 0; }

int enqueue(FilaPecas *f, Peca p) {
    if (filaCheia(f)) return 0;
    f->dados[f->tras] = p;
    f->tras = (f->tras + 1) % QSIZE;
    f->qtd++;
    return 1;
}

int dequeue(FilaPecas *f, Peca *out) {
    if (filaVazia(f)) return 0;
    *out = f->dados[f->frente];
    f->frente = (f->frente + 1) % QSIZE;
    f->qtd--;
    return 1;
}

/* Retorna ponteiro para i-esimo elemento logico (0..qtd-1) */
Peca* filaElementoLogico(FilaPecas *f, int i) {
    if (i < 0 || i >= f->qtd) return NULL;
    int idx = (f->frente + i) % QSIZE;
    return &f->dados[idx];
}

/* Inicializa fila com QSIZE pecas */
void inicializarFilaComPecas(FilaPecas *f) {
    inicializarFila(f);
    for (int i = 0; i < QSIZE; i++) enqueue(f, gerarPeca());
}

/* ---------- Pilha ---------- */

void inicializarPilha(PilhaPecas *s) {
    s->topo = -1;
    s->qtd = 0;
}

int pilhaCheia(const PilhaPecas *s) { return s->qtd == STACK_CAP; }
int pilhaVazia(const PilhaPecas *s) { return s->qtd == 0; }

int push(PilhaPecas *s, Peca p) {
    if (pilhaCheia(s)) return 0;
    s->topo++;
    s->dados[s->topo] = p;
    s->qtd++;
    return 1;
}

int pop(PilhaPecas *s, Peca *out) {
    if (pilhaVazia(s)) return 0;
    *out = s->dados[s->topo];
    s->topo--;
    s->qtd--;
    return 1;
}

/* Retorna ponteiro para elemento i da pilha (0 = base, topo = qtd-1) */
Peca* pilhaElemento(PilhaPecas *s, int i) {
    if (i < 0 || i >= s->qtd) return NULL;
    return &s->dados[i];
}

/* ---------- Exibicao de estado ---------- */

void mostrarFila(const FilaPecas *f) {
    printf("Fila de pecas\t");
    if (filaVazia(f)) {
        printf("[vazia]\n");
        return;
    }
    int idx = f->frente;
    for (int i = 0; i < f->qtd; i++) {
        Peca p = f->dados[idx];
        printf("[%c %d] ", p.tipo, p.id);
        idx = (idx + 1) % QSIZE;
    }
    printf("\n");
}

void mostrarPilha(const PilhaPecas *s) {
    printf("Pilha de reserva\t(Topo -> base): ");
    if (pilhaVazia(s)) {
        printf("[vazia]\n");
        return;
    }
    for (int i = s->topo; i >= 0; i--) {
        Peca p = s->dados[i];
        printf("[%c %d] ", p.tipo, p.id);
    }
    printf("\n");
}

void mostrarEstado(const FilaPecas *f, const PilhaPecas *s) {
    printf("\nEstado atual:\n\n");
    mostrarFila(f);
    mostrarPilha(s);
    printf("\nTabela: Visualizacao atual da fila de pecas e da pilha de reserva.\nCuradoria de TI.\n");
}

/* ---------- Operacoes compostas ---------- */

/* Tenta enfileirar uma nova peca; retorna 1 se enfileirou, 0 se fila cheia */
int reabastecerFilaSePossivel(FilaPecas *f) {
    Peca novo = gerarPeca();
    if (enqueue(f, novo)) {
        printf("Nova peca gerada e adicionada ao final da fila: [%c %d]\n", novo.tipo, novo.id);
        return 1;
    } else {
        /* normalmente nao ocorre se chamada apos uma remocao */
        printf("Aviso: nao foi possivel enfileirar nova peca (fila cheia).\n");
        return 0;
    }
}

/* Jogar peca: dequeue -> descartada. Reabastece fila. */
void acaoJogarPeca(FilaPecas *f) {
    Peca p;
    if (!dequeue(f, &p)) {
        printf("\nA fila esta vazia. Nenhuma peca para jogar.\n");
        return;
    }
    printf("\nAcao: Jogar peca -> [%c %d]\n", p.tipo, p.id);
    reabastecerFilaSePossivel(f);
}

/* Reservar peca: dequeue -> push; reabastece fila se push sucedido */
void acaoReservarPeca(FilaPecas *f, PilhaPecas *s) {
    if (pilhaCheia(s)) {
        printf("\nNao e possivel reservar: pilha de reserva cheia (capacidade %d).\n", STACK_CAP);
        return;
    }
    Peca p;
    if (!dequeue(f, &p)) {
        printf("\nA fila esta vazia. Nada a reservar.\n");
        return;
    }
    if (!push(s, p)) {
        /* nao deve ocorrer pois checamos pilha cheia acima */
        printf("Erro inesperado ao empilhar; repondo peca na fila.\n");
        enqueue(f, p);
        return;
    }
    printf("\nAcao: Reservar peca -> [%c %d] movida para o topo da pilha\n", p.tipo, p.id);
    reabastecerFilaSePossivel(f);
}

/* Usar peca reservada: pop -> usada; reabastece fila */
void acaoUsarReservada(FilaPecas *f, PilhaPecas *s) {
    Peca p;
    if (!pop(s, &p)) {
        printf("\nPilha de reserva vazia. Nao ha pecas para usar.\n");
        return;
    }
    printf("\nAcao: Usar peca reservada -> [%c %d]\n", p.tipo, p.id);
    reabastecerFilaSePossivel(f);
}

/* Trocar frente da fila com topo da pilha (swap sem alterar tamanhos) */
void acaoTrocarFrenteTopo(FilaPecas *f, PilhaPecas *s) {
    if (filaVazia(f)) {
        printf("\nFila vazia: nada a trocar.\n");
        return;
    }
    if (pilhaVazia(s)) {
        printf("\nPilha vazia: nada a trocar.\n");
        return;
    }
    Peca *frente = filaElementoLogico(f, 0);
    Peca *topo = &s->dados[s->topo];
    if (!frente || !topo) {
        printf("Erro ao localizar elementos para troca.\n");
        return;
    }
    Peca tmp = *frente;
    *frente = *topo;
    *topo = tmp;
    printf("\nAcao: Troca efetuada entre frente da fila e topo da pilha.\n");
}

/* Troca os 3 primeiros da fila com as 3 da pilha (necessitam ter >=3 elementos cada) */
void acaoTrocaMultiplas(FilaPecas *f, PilhaPecas *s) {
    if (f->qtd < 3) {
        printf("\nImpossivel realizar troca multiplas: a fila tem menos de 3 pecas.\n");
        return;
    }
    if (s->qtd < 3) {
        printf("\nImpossivel realizar troca multiplas: a pilha tem menos de 3 pecas.\n");
        return;
    }
    /* Para preservar a ordem conforme exemplo:
       - A ordem topo->base da pilha passa a ocupar posicoes 0..2 da fila (na mesma ordem).
       - As 3 primeiras da fila (0..2) passam a ocupar as posicoes topo..topo-2 da pilha,
         mantendo a mesma ordem (0->topo,1->topo-1,2->topo-2). */
    Peca tempPilha[3];
    for (int i = 0; i < 3; i++) {
        tempPilha[i] = s->dados[s->topo - i]; /* i=0 topo, i=1 topo-1 ... */
    }
    Peca tempFila[3];
    for (int i = 0; i < 3; i++) {
        Peca *pf = filaElementoLogico(f, i);
        tempFila[i] = *pf;
    }
    /* pilha(top->base) -> fila positions 0..2 (in same order top->base) */
    for (int i = 0; i < 3; i++) {
        Peca *pf = filaElementoLogico(f, i);
        *pf = tempPilha[i];
    }
    /* fila(0..2) -> pilha positions topo..topo-2 (0->topo, 1->topo-1 ...) */
    for (int i = 0; i < 3; i++) {
        s->dados[s->topo - i] = tempFila[i];
    }
    printf("\nAcao: Troca realizada entre os 3 primeiros da fila e as 3 pecas da pilha.\n");
}

/* ---------- Menu e loop ---------- */

void mostrarMenu() {
    printf("\nOpcoes disponiveis:\n\n");
    printf("Codigo\tAcao\n");
    printf("1\tJogar peca da frente da fila\n");
    printf("2\tEnviar peca da fila para a pilha de reserva\n");
    printf("3\tUsar peca da pilha de reserva\n");
    printf("4\tTrocar peca da frente da fila com o topo da pilha\n");
    printf("5\tTrocar os 3 primeiros da fila com as 3 pecas da pilha\n");
    printf("6\tMostrar estado\n");
    printf("0\tSair\n");
    printf("Tabela: Comandos para movimentar pecas entre a fila e a pilha de reserva.\nCuradoria de TI.\n");
}

/* limpa buffer stdin apos scanf */
void limparEntrada() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF) { }
}

int main() {
    srand((unsigned int) time(NULL));
    inicializarPilha(&(PilhaPecas){0}); /* placeholder to avoid unused warning when compiling in some systems */
    /* initialize actual structures */
    inicializarFilaComPecas(&fila);
    inicializarPilha(&pilha);

    printf("=== Tetris Stack - Gerenciador de Pecas (Fila %d / Pilha %d) ===\n", QSIZE, STACK_CAP);
    mostrarEstado(&fila, &pilha);
    mostrarMenu();

    int opcao;
    do {
        printf("\nOpcao escolhida: ");
        if (scanf("%d", &opcao) != 1) {
            limparEntrada();
            printf("Entrada invalida. Digite 0..6.\n");
            continue;
        }
        limparEntrada();

        switch (opcao) {
            case 1:
                acaoJogarPeca(&fila);
                mostrarEstado(&fila, &pilha);
                break;
            case 2:
                acaoReservarPeca(&fila, &pilha);
                mostrarEstado(&fila, &pilha);
                break;
            case 3:
                acaoUsarReservada(&fila, &pilha);
                mostrarEstado(&fila, &pilha);
                break;
            case 4:
                acaoTrocarFrenteTopo(&fila, &pilha);
                mostrarEstado(&fila, &pilha);
                break;
            case 5:
                acaoTrocaMultiplas(&fila, &pilha);
                mostrarEstado(&fila, &pilha);
                break;
            case 6:
                mostrarEstado(&fila, &pilha);
                break;
            case 0:
                printf("\nEncerrando gerenciador. Ate logo!\n");
                break;
            default:
                printf("Opcao invalida. Escolha 0..6.\n");
                break;
        }
    } while (opcao != 0);

    return 0;
}
